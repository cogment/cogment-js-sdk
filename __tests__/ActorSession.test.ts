/*
 *  Copyright 2021 Artificial Intelligence Redefined <dev+cogment@ai-r.com>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

import {Any as AnyPb} from 'google-protobuf/google/protobuf/any_pb';
import {createService} from '../src';
import {TrialMessageReply} from '../src/cogment/api/orchestrator_pb';
import {TrialActor} from '../src/cogment/types';
import {config} from '../src/lib/Config';
import {getLogger} from '../src/lib/Logger';
import {cogSettings} from './end-to-end/cogment-app/webapp/src/CogSettings';
import {
  ClientAction,
  EnvConfig as EnvironmentConfig,
  Message,
  Observation,
  TrialConfig,
} from './end-to-end/cogment-app/webapp/src/data_pb';

const logger = getLogger('ActorSession');

describe('ActorSession', () => {
  const TEST_MESSAGE = 'foo';
  const SUFFIX = ' bar';

  let tickIds: number[] = [];
  let lastObservation: Observation;
  let lastTimestamp: number;
  let lastResponse: string;
  let lastTickId: number;
  let lastMessage: Message;
  let sendMessagePromise: Promise<TrialMessageReply.AsObject>;

  /**
   * beforeAll hook runs a trial, generating actions that are sent to the environment as well as messages that are sent
   * to the echo actor directly.
   *
   * The trial started is passed custom trial parameters (a more advanced feature), that is accepted by the
   * configurator pre-hook to configure the environment with a suffix to append to any generated observation. See
   * cogment.ai for an overview of the Cogment framework's features.
   */
  beforeAll(async () => {
    /**
     * Entrypoint into cogment - create a service that is bound to cogSettings, and a URI to a grpc-web proxied
     * instance of the Cogment gRPC API.
     */
    const cogmentService = createService({
      cogSettings,
      grpcURL: config.connection.http,
    });

    /**
     * An actor joining a trial has two properties:
     *  - name - an arbitrary and unique identifier for _this_ actor instance in the trial
     *  - actorClass - matches an `actor_class[].name` from `cogment.yaml`
     */
    const trialActor: TrialActor = {
      name: 'client_actor',
      actorClass: 'client',
    };

    /**
     * Register an actor implementation for our actor joining the trial. Registration accepts two parameters:
     *  - trialActor - Configuration to let Cogment know which entity we will be occupying in the trial
     *  - `async (actorSession) => Promise<void>` - An async function that implements the behaviour of this actor.
     *    - actorSession - an ActorSession connected to Cogment ready to be used by the actor for interacting with the
     *      ongoing trial.
     */
    cogmentService.registerActor<ClientAction, Observation, never>(
      trialActor,
      async (actorSession) => {
        logger.info('Actor running');
        // Start the actorSession - the sdk will now start emitting events.
        actorSession.start();
        logger.info('Actor session started');

        // Stop the actorSession after the trial has run for 500ms
        setTimeout(actorSession.stop.bind(actorSession), 500);

        // Send the first action, necessary to start the trial
        const action = new ClientAction();
        actorSession.sendAction(action);

        /**
         * The implementation of the trial itself. actorSession#eventLoop will yield observations generated by the
         * environment as well as messages sent directly to this actor.
         *
         * The eventLoop will yield for each tickId a single observation, any number of messages, or any combination of
         * the two.
         */
        for await (const {
          observation,
          message: cogMessage,
          tickId,
        } of actorSession.eventLoop()) {
          // We received an observation for this tickId!
          if (observation) {
            /**
             * The Observation protobuf represents the observation space for this actor and can be found in data.proto.
             * Our observation space specifies a response (from the echo agent), and an epoch timestamp.
             */
            const response = observation.getResponse();
            const timestamp = observation.getTimestamp();
            logger.info(
              `Received an observation for tick id ${
                tickId ?? ''
              }: ${JSON.stringify(observation.toObject(), undefined, 2)}`,
            );
            if (timestamp) {
              lastTimestamp = timestamp;
            }
            if (response) {
              lastResponse = response;
            }
            lastObservation = observation;
            /**
             * Generate an action (a protobuf message of this actors action space) and send it to the environment.
             */
            const action = new ClientAction();
            action.setRequest(TEST_MESSAGE);
            actorSession.sendAction(action);
          }

          // We received a message for this tick id!
          if (cogMessage) {
            /**
             * Because message passing can send messages of any type, the SDK accepts the Any protobuf message type as
             * a payload. This requires some boilerplate serialization work to convert between your Message protobuf
             * type and the Any protobuf message type.
             */
            lastMessage = new Message();
            const newMessage = cogMessage.data?.unpack<Message>(
              (x: Uint8Array) => Message.deserializeBinary(x),
              'cogment_app.Message',
            );
            if (newMessage) {
              lastMessage = newMessage;
              logger.info(
                `Received a message for tick id ${
                  tickId ?? ''
                }: ${JSON.stringify(lastMessage.toObject(), undefined, 2)}`,
              );
            }
          }

          // Track all tickIds for testing purposes
          if (tickId !== undefined && tickId !== null && tickId >= 0) {
            lastTickId = tickId;
            tickIds.push(tickId);

            /**
             * Send a message to the echo actor! First we create an instance of our message protobuf and set some
             * properties.
             */
            const message = new Message();
            message.setRequest(TEST_MESSAGE);

            /**
             * Now we serialize into an Any protobuf message.
             */
            const anyPb = new AnyPb();
            anyPb.pack(message.serializeBinary(), 'cogment_app.Message');

            /**
             * Send the message to the echo agent!
             */
            sendMessagePromise = actorSession.sendMessage({
              from: trialActor.name,
              payload: anyPb,
              to: 'echo_echo_1',
              trialId,
            });
          }
        }
      },
    );
    // /end of actor implementation

    /**
     * We have now configured our cogmentService with static trial configuration (cogSettings), the URI to the Cogment
     * backend (grpcURL), and an actor that will participate in the trial.
     *
     * The next SDK object we instantiate is a TrialController - this connection to Cogment is used to control the
     * lifecycle of individual trials. It is possible to use a TrialController without registering an actor, for eg:
     * administering, starting, stopping, and watching for trial state changes. The controller is _not_ bound to an
     * individual trial, and can be used to control multiple trials.
     */
    const trialController = cogmentService.createTrialController();

    /**
     * Generate an instance of our TrialConfig protobuf message and set the suffix property. This trial config is
     * accepted by a configuration pre-hook and used to update the trials parameters. In the case of this application,
     * the suffix property is set on the environments configuration. The environment is coded to append this suffix to
     * the response property of each generated observation.
     */
    const trialConfig = new TrialConfig();
    const environmentConfig = new EnvironmentConfig();
    environmentConfig.setSuffix(SUFFIX);
    trialConfig.setEnvConfig(environmentConfig);

    /**
     * Tell Cogment to start a new trial! We pass it the unique name for this connected actor instance (this is used
     * for bookkeeping), as well as the (optional) customized TrialConfig protobuf message.
     *
     * In return we get a uuid for the newly created trial. Note: we have started the trial at this point, joining the
     * trial is a separate action. It is possible to join a trial without starting it.
     */
    const {trialId} = await trialController.startTrial(
      trialActor.name,
      trialConfig,
    );

    /**
     * Join the trial, using the uuid we received, and our registered TrialActor.
     */
    await trialController.joinTrial(trialId, trialActor);

    // Now that we have started and joined the trial, let it run for one second.
    // eslint-disable-next-line compat/compat
    await new Promise((resolve) => setTimeout(resolve, 1000));

    /**
     * Finally, tell Cogment to terminate the trial.
     *
     * And here ends the connected client.
     */
    return trialController.terminateTrial(trialId);
  });

  describe('#eventLoop', () => {
    test('receives observations', () => {
      expect(lastObservation).toBeInstanceOf(Observation);
    });

    test('receives an incrementing tickId', () => {
      expect(lastTickId).toBeGreaterThan(0);
    });

    test('tickIds are ordered', () => {
      for (let tickIndex = 0; tickIndex < tickIds.length - 1; tickIndex++) {
        expect(tickIds[tickIndex]).toBeLessThanOrEqual(tickIds[tickIndex + 1]);
      }
    });

    test('observation contains a timestamp from the environment', () => {
      expect(lastTimestamp).not.toBe(0);
      expect(lastTimestamp).not.toEqual('');
      expect(lastTimestamp).toBeLessThanOrEqual(Date.now());
    });
  });

  describe('#sendAction', () => {
    describe('when passed an action that contains an echo request', () => {
      test('observation contains the echo response', () => {
        expect(lastResponse).toMatch(new RegExp(`^${TEST_MESSAGE}`));
      });
    });
  });

  describe('#joinTrial', () => {
    describe('when passed a trialConfig', () => {
      test('configurator passes trialConfig to the environment', () => {
        expect(lastResponse).toEqual(`${TEST_MESSAGE}${SUFFIX}`);
      });
    });
  });

  describe('#sendMessage', () => {
    test('succeeds', async () => {
      await expect(sendMessagePromise).resolves.toBeTruthy();
    });

    test('echo agent echos a message', () => {
      expect(lastMessage.toObject()).toMatchObject({
        request: '',
        response: TEST_MESSAGE,
      });
    });
  });
});
