# JS Client SDK

_This document aims at summarizing product definition work on a big
feature. Everything is described from the end user pov, starting from
high level use cases (i.e. what the user would be able to do with this
big feature). _

_Each use case should be explicit and simple to understand. Each should
describe :_

- _why it matters to the end users, _
- _what are their requirements,_
- _how it's like to use the big feature for this case_
- _Additionally some basic principles and open problem regarding
  implementation should be introduced._

_For team planning -> this should be sufficient to define scopes and
steps in the realization._

_For engineering -> It should be sufficient to start designing and
developing._

_For marketing / sales -> It should be sufficient to understand what's
being developed and how to communicate about it._

# Some context

- The big feature is described here
  [https://trello.com/c/LLzzABvx/82-browser-js-sdk-client](https://trello.com/c/LLzzABvx/82-browser-js-sdk-client)

# Use Cases

## I - As a javascript developer, I want to implement a webapp that let humans join a trial as Cogment actor.

### A - Why is it important?

- That's the way to put humans in the loop :)

### B - What are the requirements?

- I need to be able to start a trial
- I need to be able to join a starting trial with a human actor
- I need to be able to join ongoing trials (eg: in the case of a web-ui
  where the user may have reloaded the page while a controlled trial is
  ongoing)
- This should work in a webapp context

### C - How should it be accessible by the end user?

1. Setup the application in a cogment.yaml and data.proto files

   - It include a list of services that are defined in several
     directories and have an associated language no need to pass
     --python_dir or --js-dir e.g.

   ```yaml
   services:
     my_browser_app:
       language: javascript-browser
       dir: ./mba
   ```

2. Run `cogment generate` for types and settings or `cogment init` for
   the full scaffolding
   - Types definition from `data.proto` gets generated
   - `mba/cog_settings.js` gets generated
   - `mba/package.json` having set
     - The app name to `my_browser_app`
     - Scripts to build the package, run an auto restart dev server,
       start a simple production server
     - Webpack (or other) basic configuration
     - A very basic scaffolding of a cogment using module
   - `docker-compose.yaml` is edited to add the browser server (and an
     envoy setup if not already existing).
3. Implement a browser front end application the way you want.
4. Implement the cogment side of things that way

   ```typescript
   import {createService} from 'cogment';

   import cog_settings from './cog_settings';

   import {ROCK, PAPER, SCISSORS, TrialConfig} from './data-pb2';

   const service = cogment.createService({
     settings: cog_settings,
   });

   service.registerActor(
     {name: 'human', classes: ['player']},

     async (actorSession) => {
       actorSession.start();

       for (await {observation, reward, message} in actorSession.run()) {
         if (observation != null) {
           document.querySelector('.p1Score').innerHTML = observation.p1_score;

           document.querySelector('.p1Score').innerHTML = observation.p2_score;

           const move = await new Promise((resolve) => {
             const playRock = () => {
               document
                 .querySelector('button.rock')

                 .removeEventListener('click', playRock);

               resolve(ROCK);
             };

             document
               .querySelector('button.rock')

               .addEventListener('click', playRock);

             // [...]
           });

           actorSession.doAction(move);
         }

         if (message != null) {
           if (message.payload == 'windy') {
             document.querySelector('button.paper').disabled = true;
           } else {
             document.querySelector('button.paper').disabled = false;
           }
         }

         if (reward != null) {
           document.querySelector('.reward').innerHTML =
             reward.value * reward.confidence;
         }
       }
     },
   );

   const trialController = service.createTrialController(
     '[http://orchestrator-gateway:9000](http://orchestrator-gateway:9000)',
   );

   const {trialId, actors} = await trialController.startTrial({
     config: new TrialConfig(),
   });

   document
     .querySelector('button.terminate')
     .addEventListener(
       'click',
       async () => await trialController.terminateTrial(trialId),
     );
   await trialController.joinTrial({
     trialId,
     actorImplName: 'human',
     actorId: 0,
   });
   ```

5. run `cogment start`
   - it should work.

### D - What are the involved modules?

- cogment-cli
  - javascript user proto generation
  - cog_settings generation
  - application scaffolding
- cogment-js-sdk [new]

## II - As a javascript developer, I want to implement a webapp that visualizes a simulation

### A - Why is it important?

- Web app are one (easy ?) way to implement a "real-time" visualization
  of what's going on in an environment.

### B - What are the requirements?

- I need to be able to receive observations.
- This should work in a webapp context

### C - How should it be accessible by the end user?

- Something "watching" the simulation is also an agent in cogment, it's
  simply an agent that doesn't take any action. This usecase is
  therefore achievable in exactly the same way than the
  [v1.0-proposal](#c-how-should-it-be-accessible-by-the-end-user).

### D - What are the involved modules?

- cogment-js-sdk [new]

## III - As a JS developer I want to implement webapp able to start/stop/list trials

### A - Why is it important?

- Being able to implement a controller for the trials in a given
  application is a common need
- This part of the SDK will be needed to add features to the cogment
  dashboard

### B - What are the requirements?

- List ongoing trials and retrieve their configuration and status
- Start and end trials
- See trial details
- This should work in a webapp context

### C - How should it be accessible by the end user?

```typescript
import {createService, TrialStatus} from 'cogment-api';
import {List} from 'postcss/lib/list';
import {cursor} from 'sisteransi';
import {end} from 'worker-farm';
import to = cursor.to;
('cogment');

const service = cogment.createService({
  settings: cog_settings,
});

const trialController = service.createTrialController(
  '[http://orchestrator-gateway:9000](http://orchestrator-gateway:9000)',
);

// Retrieving current trials (there might be a lot some we stream the response

for (await trial in trialController.retrieveTrials({
  statuses: [TrialStatus.STARTED, TrialStatus.TERMINATED],

  startDateFrom: new Date(),

  startDateTo: new Date(),
})) {
  console.log(trial.trialId);

  console.log(trial.status);

  console.log(trial.startDate);

  console.log(trial.endDate);

  console.log(trial.configuration);

  console.log(trial.actors);

  //[...]

  await trialController.terminateTrial(trial.trialId);
}

// Subscribing to trial events

trialController.addEventListener(TrialStatus.ALL, ({trialId, status}) => {
  console.log(`trial ${trialId} is now ${status}`);

  //    [...]
});

// Starting a trial (as defined before)

const {
  trialId,
  status,
  startDate,
  endDate,
  configuration,
  actors,
} = await trialController.startTrial({config: new TrialConfig()});
```

### D - What are the involved modules?

- cogment-js-sdk [new]

## IV - As a javascript developer, I want to implement agents / actors / environments services with node.js [⚠️ out of scope for now]

### A - Why is it important?

### B - What are the requirements?

### C - How should it be accessible by the end user?

### D - What are the involved modules?

# Brainstorm & notes

## User experience goal

- Start a trial
- Join a trial
- Send an action and receive an observation
- Register side channel message handlers and receive side-channel
  messages
- Send side-channel messages
- End a trial

## How it would look like to use it?

Rough code structure would look something like:

```protobuf
syntax = "proto3";

// Message send from the environment to the operator

message RecommenderReward {

    float reward = 1;

}

// Message send from the operator to the recommender

message RecommenderType {

    int32 type = 1;

}

// Request ETA from the web-client to the Env

message EtaRequest {

    int32 event_id = 1;

}

// Eta from a unit

message DispatchUnitEta {

    string dispatch_unit_id = 1;

    float eta = 2;

}

// Eta assigned between the event and the dispatch units

message Eta {

    int32 event_id = 1;

    repeated DispatchUnitEta dispatch_unit_eta = 2;

}

message Score {

    uint32 score = 1;

}

message SideChannelMessage {

    oneof message {

        Score score = 1;

        Eta eta = 2;

        RecommenderReward recommender_reward = 3;

    }

}
```

```typescript
import * as cogSettings from './cog_settings';

import {grpc} from '@improbable-eng/grpc-web';
import is from '@sindresorhus/is';
import {spread} from 'q';
import {cursor} from 'sisteransi';
import to = cursor.to;
import even = is.even;
import * as protos from './data_pb';

type CogmentSettings = typeof cogSettings;

type ServerSideChannelMessageType = 'score' | 'eta' | 'recommenderReward'; // this could be automatically inferred from the SideChannelMessage type

type ClientSideChannelMessageType = 'dispatchUnitSelected';

abstract class CogmentClient {
  protected constructor(private cogSettings: CogmentSettings) {}

  abstract async startTrial(): Promise<CogmentTrial>;

  abstract async joinTrial(trialId: string): Promise<CogmentTrial>;

  abstract async endTrial(trialId: string): Promise<unknown>;
}

abstract class CogmentTrial {
  abstract registerSideChannelHandler(
    messageType: SideChannelMessageType,
    handlr: (err: Error, message: MessageType.AsObject) => unknown,
  );

  // Send an action and receive an observation

  abstract async doAction<A = any, O = any>(action: A): Promise<any>;

  abstract async sendSideChannelMessage(
    messageType: ClientSideChannelMessageType,
    message: Message.AsObject,
  ): Promise<unknown>;
}
```

### Hide protobuf implementation details from SDK consumers

Pre 1.0 the various SDK's API's exchanged raw protobuf instances with
it's consumers, which bound usage of the SDK to protobufs, the specific
protobuf libraries we use, and even the specific version.

For the 1.0 SDK (specifically on the Javascript side), I propose making
the SDK's API protobuf agnostic... The API would only communicate using
plain Javascript types instead of protobuf instances.

#### Advantages

- Users of the SDK do not require knowledge of protobuf's and how to
  manipulate them (which can vary depending on which client library you
  use) - less learning curve
- The SDK's "external" non-protobuf API would have the advantage of
  masking the implementation details of the transport / data encoding.
  This allows us to muck with the implementation of the "internal"
  protobuf API while leaving the "external" API stable (not necessarily!
  But does help enable it, for example, if we add or remove a field from
  a protobuf message, our users do not have to change their code).
- Concentrates all of the logic for interacting with protobuf message
  instance in a single module (focused responsibility, instead of having
  protobuf logic spread throughout app code). No need to guess if you
  are dealing with a protobuf instance or a javascript object.
- Makes changing protobuf implementation details easier (version
  changes, swapping out protobuf libraries altogether, using different
  rpc transports or even replacing grpc+protobuf's with a communication
  protocol that is supported by browsers) altogether more feasible (not
  easy, but having the protobuf logic in a single place means less
  cognitive load when refactoring)
