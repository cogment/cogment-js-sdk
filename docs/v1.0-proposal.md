<!-- The first section "Release notes" is required if you want to have your release post blog MR auto generated. Currently in BETA, details on the **release post item generator** can be found in the handbook:  https://about.gitlab.com/handbook/marketing/blog/release-posts/#release-post-item-generator and this video: https://www.youtube.com/watch?v=rfn9ebgTwKg. The next four sections: "Problem to solve", "Intended users", "User experience goal", and "Proposal", are strongly recommended in your first draft, while the rest of the sections can be filled out during the problem validation or breakdown phase. However, keep in mind that providing complete and relevant information early helps our product team validate the problem and start working on a solution. -->

### Release notes

<!-- What is the problem and solution you're proposing? This content sets the overall vision for the feature and serves as the release notes that will populate in various places, including the [release post blog](https://about.gitlab.com/releases/categories/releases/) and [Gitlab project releases](https://gitlab.com/gitlab-org/gitlab/-/releases). " -->

### Problem to solve

<!-- What problem do we solve? Try to define the who/what/why of the opportunity as a user story. For example, "As a (who), I want (what), so I can (why/value)." -->

- As a javascript developer, I want to implement a webapp that visualizes a simulation.
  - I need to be able to receive an observation.
- As a javascript developer, I want to implement a webapp that acts as a Cogment actor.
  - I need to be able to start a trial
  - I need to be able to join a trial
  - I need to be able to send an action and receive an observation
  - I need to be able to send and receive side channel messages
- As a javascript developer, I want visibility into what the cogment framework is doing (nice to have):
  - List ongoing trials
  - End trials
  - Join arbitrary trials (eg: in the case of a web-ui where the user may have reloaded the page)
  - See trial details
- As a javascript developer, I want to implement agents / actors / environments on node.js (very very nice to have, not in scope for v1 but something to keep in mind).

### Intended users

<!-- Who will use this feature? If known, include any of the following: types of users (e.g. Developer), personas, or specific company roles (e.g. Release Manager). It's okay to write "Unknown" and fill this field in later.

Personas are described at https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/

* [Cameron (Compliance Manager)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#cameron-compliance-manager)
* [Parker (Product Manager)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#parker-product-manager)
* [Delaney (Development Team Lead)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#delaney-development-team-lead)
* [Presley (Product Designer)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#presley-product-designer)
* [Sasha (Software Developer)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#sasha-software-developer)
* [Devon (DevOps Engineer)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#devon-devops-engineer)
* [Sidney (Systems Administrator)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#sidney-systems-administrator)
* [Sam (Security Analyst)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#sam-security-analyst)
* [Rachel (Release Manager)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#rachel-release-manager)
* [Alex (Security Operations Engineer)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#alex-security-operations-engineer)
* [Simone (Software Engineer in Test)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#simone-software-engineer-in-test)
* [Allison (Application Ops)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#allison-application-ops)
* [Priyanka (Platform Engineer)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#priyanka-platform-engineer)
* [Dana (Data Analyst)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#dana-data-analyst)
* [Eddie (Content Editor)](https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/#eddie-content-editor)
-->

### User experience goal

<!-- What is the single user experience workflow this problem addresses?
For example, "The user should be able to use the UI/API/.gitlab-ci.yml with GitLab to <perform a specific task>"
https://about.gitlab.com/handbook/engineering/ux/ux-research-training/user-story-mapping/ -->

- Start a trial
- Join a trial
- Send an action and receive an observation
- Register side channel message handlers and receive side-channel messages
- Send side-channel messages
- End a trial

### Proposal

<!-- How are we going to solve the problem? Try to include the user journey! https://about.gitlab.com/handbook/journeys/#user-journey -->

Rough code structure would look something like:

```protobuf
syntax = "proto3";

// Message send from the environment to the operator
message RecommenderReward {
    float reward = 1;
}

// Message send from the operator to the recommender
message RecommenderType {
    int32 type = 1;
}

// Request ETA from the web-client to the Env
message EtaRequest {
    int32 event_id = 1;
}

// Eta from a unit
message DispatchUnitEta {
    string dispatch_unit_id = 1;
    float eta = 2;
}

// Eta assigned between the event and the dispatch units
message Eta {
    int32 event_id = 1;
    repeated DispatchUnitEta dispatch_unit_eta = 2;
}

message Score {
    uint32 score = 1;
}

message SideChannelMessage {
    oneof message {
        Score score = 1;
        Eta eta = 2;
        RecommenderReward recommender_reward = 3;
    }
}

```

```typescript
import {Message} from 'protobufjs';
import * as cogSettings from './cog_settings';
import * as protos from './data_pb';

type CogmentSettings = typeof cogSettings;
type ServerSideChannelMessageType = 'score' | 'eta' | 'recommenderReward'; // this could be automatically inferred from the SideChannelMessage type
type ClientSideChannelMessageType = 'dispatchUnitSelected';

abstract class CogmentClient {
  protected constructor(private cogSettings: CogmentSettings) {}
  abstract async startTrial(): Promise<CogmentTrial>;
  abstract async joinTrial(trialId: string): Promise<CogmentTrial>;
  abstract async endTrial(trialId: string): Promise<unknown>;
}

abstract class CogmentTrial {
  abstract registerSideChannelHandler(
    messageType: ClientSideChannelMessageType,
    handler: (
      err: Error,
      message: protos.SideChannelMessage.AsObject
    ) => unknown
  );
  // Send an action and receive an observation
  abstract async doAction<A = any, O = any>(action: A): Promise<O>;
  abstract async sendSideChannelMessage(
    messageType: ClientSideChannelMessageType,
    message: Message.AsObject
  ): Promise<unknown>;
}
```

### Further details

<!-- Include use cases, benefits, goals, or any other details that will help us understand the problem better. -->

#### Hide protobuf implementation details from SDK consumers

Pre 1.0 the various SDK's API's exchanged raw protobuf instances with it's consumers, which bound usage of the SDK to protobufs, the specific protobuf libraries we use, and even the specific version.

For the 1.0 SDK (specifically on the Javascript side), I propose making the SDK's API protobuf agnostic... The API would only communicate using plain Javascript types instead of protobuf instances.

##### Advantages

- Users of the SDK do not require knowledge of protobuf's and how to manipulate them (which can vary depending on which client library you use) - less learning curve
- The SDK's "external" non-protobuf API would have the advantage of masking the implementation details of the transport / data encoding. This allows us to muck with the implementation of the "internal" protobuf API while leaving the "external" API stable (not necessarily! But does help enable it, for example, if we add or remove a field from a protobuf message, our users do not have to change their code).
- Concentrates all of the logic for interacting with protobuf message instance in a single module (focused responsibility, instead of having protobuf logic spread throughout app code). No need to guess if you are dealing with a protobuf instance or a javascript object.
- Makes changing protobuf implementation details easier (version changes, swapping out protobuf libraries altogether, using different rpc transports or even replacing grpc+protobuf's with a communication protocol that is supported by browsers) altogether more feasible (not easy, but having the protobuf logic in a single place means less cognitive load when refactoring)

### Permissions and Security

<!-- What permissions are required to perform the described actions? Are they consistent with the existing permissions as documented for users, groups, and projects as appropriate? Is the proposed behavior consistent between the UI, API, and other access methods (e.g. email replies)?
Consider adding checkboxes and expectations of users with certain levels of membership https://docs.gitlab.com/ee/user/permissions.html
* [ ] Add expected impact to members with no access (0)
* [ ] Add expected impact to Guest (10) members
* [ ] Add expected impact to Reporter (20) members
* [ ] Add expected impact to Developer (30) members
* [ ] Add expected impact to Maintainer (40) members
* [ ] Add expected impact to Owner (50) members -->

### Documentation

<!-- See the Feature Change Documentation Workflow https://docs.gitlab.com/ee/development/documentation/workflow.html#for-a-product-change

* Add all known Documentation Requirements in this section. See https://docs.gitlab.com/ee/development/documentation/feature-change-workflow.html#documentation-requirements
* If this feature requires changing permissions, update the permissions document. See https://docs.gitlab.com/ee/user/permissions.html -->

### Availability & Testing

<!-- This section needs to be retained and filled in during the workflow planning breakdown phase of this feature proposal, if not earlier.

What risks does this change pose to our availability? How might it affect the quality of the product? What additional test coverage or changes to tests will be needed? Will it require cross-browser testing?

Please list the test areas (unit, integration and end-to-end) that needs to be added or updated to ensure that this feature will work as intended. Please use the list below as guidance.
* Unit test changes
* Integration test changes
* End-to-end test change

See the test engineering planning process and reach out to your counterpart Software Engineer in Test for assistance: https://about.gitlab.com/handbook/engineering/quality/test-engineering/#test-planning -->

### What does success look like, and how can we measure that?

<!--
Define both the success metrics and acceptance criteria. Note that success metrics indicate the desired business outcomes, while acceptance criteria indicate when the solution is working correctly. If there is no way to measure success, link to an issue that will implement a way to measure this.

Create tracking issue using the the Snowplow event tracking template. See https://gitlab.com/gitlab-org/gitlab/-/blob/master/.gitlab/issue_templates/Snowplow%20event%20tracking.md
-->

### What is the type of buyer?

<!-- What is the buyer persona for this feature? See https://about.gitlab.com/handbook/marketing/product-marketing/roles-personas/buyer-persona/
In which enterprise tier should this feature go? See https://about.gitlab.com/handbook/product/pricing/#four-tiers -->

### Is this a cross-stage feature?

<!-- Communicate if this change will affect multiple Stage Groups or product areas. We recommend always start with the assumption that a feature request will have an impact into another Group. Loop in the most relevant PM and Product Designer from that Group to provide strategic support to help align the Group's broader plan and vision, as well as to avoid UX and technical debt. https://about.gitlab.com/handbook/product/#cross-stage-features -->

### Links / references

<!--  Label reminders - you should have one of each of the following labels.
Read the descriptions on https://gitlab.com/gitlab-org/gitlab/-/labels to find the correct ones -->
